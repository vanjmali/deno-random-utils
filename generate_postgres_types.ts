import * as Postgres from "https://deno.land/x/postgres@v0.17.0/mod.ts";

if (Deno.args.includes("--help") || Deno.args.length !== 2) {
	console.log(
		`Arguments: postgres://user:password@host:port/database output.d.ts`,
	);
	Deno.exit(0);
}

const knownTypes = new Map([
	["character varying", "string"],
	["character", "string"],
	["text", "string"],
	["uuid", "string"],
	["integer", "number"],
	["bigint", "number"],
	["numeric", "number"],
	["double precision", "number"],
	["boolean", "boolean"],
	["timestamp without time zone", "Date"],
	["jsonb", "Record<string, unknown>"],
	["json", "Record<string, unknown>"],
]);

const database = new Postgres.Client(Deno.args[0]);

await database.connect();

// Get all schemas and tables and store them in a map of typescript interfaces in following format:
// interface Schema {
// 	table: {
// 		column: string;
// 		...
// 	}
// }
const schemas = await database.queryObject<
	Record<
		| "schema_name"
		| "table_name"
		| "column_name"
		| "column_default"
		| "data_type"
		| "is_nullable",
		string
	>
>(`
	select
		table_schema as schema_name,
		table_name,
		column_name,
		column_default,
		data_type,
		is_nullable
	from information_schema.columns
	where table_schema not in ('pg_catalog', 'information_schema')
	order by table_schema, table_name, ordinal_position
`);

const schemaMap = new Map<
	string,
	Map<
		string,
		Map<
			string,
			{
				type: string;
				comments: Record<string, string>;
				values: unknown[];
				isNullable: boolean;
			}
		>
	>
>();
for (const schema of schemas.rows) {
	if (!schemaMap.has(schema.schema_name)) {
		schemaMap.set(schema.schema_name, new Map());
	}
	if (!schemaMap.get(schema.schema_name)!.has(schema.table_name)) {
		schemaMap.get(schema.schema_name)!.set(schema.table_name, new Map());
	}
	schemaMap.get(schema.schema_name)!.get(schema.table_name)!.set(
		schema.column_name,
		{
			type: knownTypes.get(schema.data_type) ?? "unknown",
			comments: {
				type: schema.data_type,
				default: schema.column_default,
				can_be_null: schema.is_nullable,
			},
			isNullable: schema.is_nullable === "YES",
			values: await database.queryArray<[unknown]>(
				`select distinct ${schema.column_name} from ${schema.schema_name}.${schema.table_name}`,
			).then((v) => v.rows.flat().map((v) => `'${v}'`)),
		},
	);
}

console.dir(Deno.inspect(schemaMap, {
	depth: Infinity,
	colors: true,
	compact: false,
}));

// Generate typescript interfaces
const schemaTypes = [
	"// This file is auto-generated",
	"// Do not edit this file manually",
	"",
	`export interface Database {`,
];

const valueEnums: string[] = [];

for (const [schemaName, tables] of schemaMap) {
	const tableTypes = [];
	for (const [tableName, columns] of tables) {
		const columnTypes = [];
		for (const [columnName, columnData] of columns) {
			columnTypes.push(`/**`);
			for (
				const [commentName, commentValue] of Object.entries(
					columnData.comments,
				)
			) {
				columnTypes.push(` * @${commentName} ${commentValue}`);
			}
			columnTypes.push(` */`);
			columnTypes.push(
				`${columnName}${columnData.isNullable ? "?:" : ":"} ${
					columnData.type + (columnData.isNullable ? " | null" : "")
				};`,
			);

			if (columnData.values.length > 0) {
				// name of enum: SchemaTableColumn
				const enumName = [schemaName, tableName, columnName].map((v) =>
					v.split("_")
				).flat().map((v) => v[0].toUpperCase() + v.slice(1)).join("");
				valueEnums.push(
					`export type Values${enumName} = ${
						columnData.values.map((v) =>
							(v as string).toString().replaceAll(`'`, "`")
						).join(" | ")
					};`,
				);
			}
		}
		tableTypes.push(
			`${tableName}: {\n			${
				columnTypes.join("\n			")
			}\n		};`,
		);
	}
	schemaTypes.push(
		`	${schemaName}: {\n		${
			tableTypes.join("\n		")
		}\n	};`,
	);
}

schemaTypes.push(`}`);

// add value enums
schemaTypes.push(...valueEnums);

// add Table type that can be used to access all tables
schemaTypes.push(`export type Schema<T extends keyof Database> = Database[T];`);
schemaTypes.push(
	`export type Table<T extends Schema, K extends keyof T> = T[K];`,
);
schemaTypes.push(
	`export type TableColumn<T extends Table, K extends keyof T> = T[K];`,
);

// Write typescript interfaces to file
await Deno.writeTextFile(Deno.args[1], schemaTypes.join("\n"));
